The primary objective of this section is to identify potential targets within the network to which you are directly connected. This approach is tailored for internal network attacks. Conducting this type of reconnaissance externally is generally ineffective due to common security measures like ICMP blocking and the inability to access Layer 2 protocols such as ARP from an external vantage point.

While Nmap, particularly with the `-sn` switch, is an excellent tool for this purpose, it's worth noting that Nmap isn't a standard utility on many systems. A viable alternative is to use a `for` loop in conjunction with the ping command to sweep the network for responsive devices. This method effectively identifies active hosts, although it does not leverage more advanced host discovery techniques. Such techniques include ARP requests, LLMNR, mDNS, and others, which Nmap can perform when granted sudo privileges. These advanced methods can add an element of depth and 'fun' to the discovery process.

---
# This is a basic for loop in Nmap
#### Using Nmap if its on the system could work but this will also write a file to the system and is a good way to get caught but this is also a good way to see if the blue team is tracking you.

```shell
sudo nmap -iL scope -sn -n | tee ping_sweep
```

### Breakdown of the Nmap command for network scanning and outputting results to a file

1. `sudo`:
   - Runs the command with superuser privileges to ensure full access to network interfaces.

2. `nmap`:
   - Network Mapper, a tool for network discovery and security auditing.

3. `-iL scope`:
   - Instructs Nmap to read the list of target hosts from a file named `scope`. This file should contain the IP addresses or hostnames of the targets. Alternatively, you can directly add the IP addresses in the command if you prefer not to use the `-iL` option and `scope` file.

4. `-sn`:
   - Enables ping scanning (also known as 'ping sweep'). This option tells Nmap to send ICMP echo requests (ping) to each target, but it does not perform port scanning.

5. `-n`:
   - Skips DNS resolution. This option speeds up the scan by avoiding the DNS resolution of the IP addresses.

6. `| tee ping_sweep`:
   - Pipes (`|`) the output of the Nmap command into the `tee` command, which displays the output on the screen and simultaneously writes it to a file named `ping_sweep`.


---
# Windows Loop

```shell
for /l %i in (1,1,254) do @ping -n 1 -w 100 192.168.0.%i | find "Reply"
```

## Breakdown of the batch command for performing a ping sweep in a Windows environment

1. `for /l %i in (1,1,254)`: 
   - This is a loop that iterates from 1 to 254. 
   - The loop variable `%i` takes on each value in this range, representing the last octet of an IP address.

2. `do @ping -n 1 -w 100 192.168.0.%i`:
   - This part of the command executes the `ping` command for each iteration of the loop.
   - `-n 1` tells the ping command to send only one ICMP echo request to each IP address.
   - `-w 100` sets the timeout for each ping to 100 milliseconds.
   - `192.168.0.%i` specifies the target IP address for the ping, where `%i` is replaced by the current loop iteration number.

3. `| find "Reply"`:
   - This part of the command filters the output of the ping command.
   - It uses the `find` command to display only those lines that contain the word "Reply".
   - "Reply" indicates a successful response from the pinged host, showing that the host is active.


---
# This is a basic for loop in Linux

#### This script performs a network sweep to identify active hosts in a local subnet.

```Bash
for i in {1..254} ;do (ping -c 1 192.168.1.$i | grep "bytes from" &) ;done
```

## loop in Linux breakdown

1. **Loop Initialization**:
   - `for i in {1..254}`: This initializes a `for` loop, iterating through a range of numbers from 1 to 254. Each number represents the last octet of an IP address in the subnet 192.168.1.0/24.

2. **Ping Command**:
   - `ping -c 1 192.168.1.$i`: In each iteration of the loop, this command pings the IP address at 192.168.1.X, where X is the current loop iteration number (1 to 254).
   - The `-c 1` option ensures that only a single ICMP echo request (ping) is sent to each IP address.

3. **Output Filtering**:
   - `grep "bytes from"`: This part of the command filters the output of the ping command, looking for the phrase "bytes from". This phrase is part of the standard response for a successful ping, indicating that the host at the specific IP address is active and responding.

4. **Background Execution**:
   - The `&` at the end of the command places each ping command in the background. This allows the script to continue to the next IP address without waiting for the current ping command to finish.

5. **Loop Conclusion**:
   - `done`: Marks the end of the `for` loop. The script concludes after iterating through all the IP addresses in the specified range, effectively performing a ping sweep to identify active hosts in the subnet.


---

Write that output to file by copying it off the victim and moving it to your attacker machine. REMEMBER to never leave sensitive data on a victim.

# Clean up

Now that we have copied all that to our scope file or any other file name we like its time to clean it all up.

```shell
cat scope | awk -F " " '{print $4}' | awk -F ":" '{print $1}' | sort -V >> internal_targets
```

## Command breakdown

1. `cat scope`:
   - This command reads the contents of the file named `scope`.
   - `scope` is expected to be a file containing network-related data, such as scan results.

2. `awk -F " " '{print $4}'`:
   - This `awk` command splits each line of the input (from `scope`) using spaces (`" "`) as field separators.
   - It then prints the fourth field (`$4`) of each line. This field is expected to contain specific data of interest, such as an IP address.

3. `awk -F ":" '{print $1}'`:
   - Another `awk` command, this time using a colon (`":"`) as the field separator.
   - It prints the first part (`$1`) of each field. If the data includes port numbers or other appended information after a colon, this command removes that, leaving only the IP address or primary data.

4. `sort -V`:
   - This command sorts the input data in version number order (`-V`).
   - It's particularly useful for sorting IP addresses or similar data in a logical order rather than simple alphanumeric order.

5. `>> internal_targets`:
   - Appends the sorted output to a file named `internal_targets`.
   - If `internal_targets` doesn't exist, it will be created; if it does exist, the new data is added to the end of the file.

## Making dir for each new IP

```shell
cat internal_targets | xargs mkdir

for i in 192.*;do echo $i > ./$i/scope; done
```

1. `cat internal_targets | xargs mkdir`:
   - `cat internal_targets`: This command reads the contents of the file named `internal_targets`.
   - `xargs mkdir`: The `xargs` command takes the output from `cat` (the contents of `internal_targets`) and uses it as input for the `mkdir` command, creating directories named after each line in the `internal_targets` file.

2. `for i in 192.*; do echo $i > ./$i/scope; done`:
   - This is a `for` loop that iterates over all items in the current directory matching the pattern `192.*`. This pattern typically matches directory names that start with `192.`.
   - `echo $i > ./$i/scope`: For each iteration, this command echoes the current item name (assumed to be an IP address or a similar identifier) and redirects it into a file named `scope` inside the corresponding directory.
   - The loop creates or overwrites a file named `scope` in each `192.*` directory with the directory name itself, presumably to use as a reference or identifier for later processes.

---

Then I made a loop that will scan all the targets and make a file in each folder with the output see [ProxyChains](ProxyChains.md)

```shell
for ip in $(cat targets);do sudo proxychains nmap -F -sT -Pn $ip | tee ./$ip/fast_scan; done
```
